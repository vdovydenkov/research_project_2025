## **3. Разработка архитектуры программного средства**

### 3.1. Проектирование структуры системы

#### 3.1.1. Уровни и модули

1. **Клиентская часть (Frontend)**

   * Одностраничное приложение для последовательного отображения учебных страниц.
   * Компоненты:

     * **AuthClient** — управление идентификацией через cookies и URL-параметры.
     * **Navigator** — логика навигации по этапам тренажёра.
     * **ProgressDisplay** — индикатор процента прохождения, счётчик этапов и затраченного времени.
     * **TutorDashboard** — панель преподавателя для регистрации учеников, отслеживания их прогресса и отправки подсказок.

2. **Серверная часть (Backend)**

   * Четырёхзвенная структура:

     1. **REST API** — маршрутизация HTTP-запросов.
     2. **Контроллеры** — авторизация, базовая валидация, преобразование запросов в вызовы сервисного слоя.
     3. **Сервисный слой** — реализация ключевых сценариев:

        * Автоматическая регистрация и идентификация пользователя.
        * Фиксация завершения этапов и обновление прогресса.
        * Управление связями преподаватель–ученик и подсказками.
     4. **DAO (Data Access Objects)** — взаимодействие с PostgreSQL через ORM, с возможностью выполнения оптимизированных запросов.

3. **База данных (PostgreSQL)**

   * Логическая схема соответствует инфологической модели:

     * Таблицы: `Users`, `Tutors`, `Topics`, `Levels`, `User_Level`, `Progress`, `Sessions`, `Hints`.
     * Внешние ключи и индексы обеспечивают целостность и производительность.
     * Триггер при вставке в `User_Level` автоматически обновляет агрегированные данные в таблице `Progress`.

4. **Инфраструктура и отказоустойчивость**

   * **Контейнеризация**: все сервисы упакованы в Docker для воспроизводимой среды.
   * **Реверс-прокси (Nginx)** — маршрутизация запросов и раздача статических ресурсов.
   * **Резервное копирование**:

     * БД — ежечасный `pg_dump`, хранится одна последняя копия.
     * Статические файлы — суточное копирование, хранится одна последняя копия.
   * **Мониторинг и логирование**: сбор метрик и логов для оперативного выявления сбоев и анализа работы системы.

### 3.2. Описание взаимодействия компонентов

#### 3.2.1. Сценарий «Старт / Продолжение»

1. Клиент отправляет GET `/api/session/start`.
2. Контроллер проверяет наличие `user_id` в cookie или URL-параметре.
3. При отсутствии:

   * Создаются записи в таблицах `Users` и `Sessions`.
   * Клиенту возвращается URL первой страницы тренажёра.
4. При наличии:

   * Из таблиц `User_Level` и `Progress` извлекаются данные о последнем пройденном этапе и проценте прохождения.
   * Клиент получает URL для продолжения и текущее состояние прогресса.

#### 3.2.2. Сценарий «Прохождение этапа\*\*

1. Клиент запрашивает GET `/api/levels/{level_id}`, получая описание этапа и инструкции.
2. После выполнения задания отправляет POST `/api/user_levels` с `{ user_id, level_id, session_id }`.
3. Сервисный слой проверяет отсутствие дубликатов и создаёт запись в `User_Level`.
4. Триггер в СУБД обновляет соответствующую запись в таблице `Progress`.
5. Ответ API содержит обновлённый процент прохождения и суммарное время, после чего клиент обновляет индикатор и предлагает перейти к следующему этапу.

#### 3.2.3. Сценарий «Работа преподавателя\*\*

1. **Регистрация преподавателя**: POST `/api/tutors/register` — создание записи в таблице `Tutors`, отправка письма с подтверждением на email.
2. **Управление учениками**:

   * **Создание**: POST `/api/tutors/{tutor_id}/students` — создаёт запись в `Users` с заполненным `tutor_id`.
   * **Список**: GET `/api/tutors/{tutor_id}/students` — возвращает досье ассоциированных учеников (`user_id`, `name`, `progress`).
   * **Удаление связи**: DELETE `/api/tutors/{tutor_id}/students/{user_id}` — обнуляет поле `tutor_id` у ученика.
3. **Подсказки**:

   * **Отправка**: POST `/api/hints` с `{ tutor_id, user_id, message }` — создание новой записи в `Hints`.
   * **Чтение**: GET `/api/hints/{user_id}` — получение непрочитанных подсказок и сохранение времени `read_at`.

#### 3.2.4. Логирование и мониторинг

* HTTP-запросы и ключевые события (регистрация, завершение этапа, отправка подсказок) фиксируются в логах с указанием `session_id` и `user_id`.
* Метрики системы (latency, error rate, active sessions) собираются инструментами мониторинга для своевременного реагирования на инциденты.

### 3.3. Выбор технологий

В процессе разработки архитектуры было проведено всестороннее сравнение доступных инструментов и фреймворков с целью обеспечить баланс между скоростью разработки, простотой сопровождения и качеством конечного продукта. При выборе технологий учитывались следующие факторы:

* **Фреймворк для серверной части (Flask):**
  Flask обладает минималистичным ядром и позволяет строить REST‐сервисы с гибкой организацией слоёв. Он хорошо интегрируется с SQLAlchemy, имеет обширную экосистему расширений (для валидации, аутентификации, миграций) и прост в освоении.

* **ORM (SQLAlchemy):**
  Использование ORM ускоряет разработку моделей данных, упрощает миграции схемы (через Alembic) и снижает вероятность ошибок при формировании запросов. Для критичных по производительности участков предусмотрена возможность написания “сырых” SQL-запросов.

* **Одностраничное приложение (SPA) на React/Vue/Angular:**
  SPA обеспечивает динамичную подгрузку контента без перезагрузки страницы, что критично для пользователей скринридера, поскольку позволяет сохранять контекст и фокус интерфейса. Изучение и выбор конкретного фреймворка опирались на наличие готовых библиотек для управления состоянием и маршрутизацией.

* **PostgreSQL:**
  Надёжная СУБД с поддержкой транзакций, индексов на сложных типах данных и расширениями.
* **Docker для контейнеризации:**
  Контейнеризация обеспечивает идентичность сред разработки и продакшн, упрощает масштабирование и развёртывание сервисов.

---

### 3.4. Выработка требований к производительности и безопасности

На основании нефункциональных требований, анализа результатов опроса и потенциальных рисков были сформулированы следующие ключевые критерии:

1. **Производительность и отклик интерфейса:**

   * Время загрузки страницы не должно превышать 3 секунд при одновременной работе до 100 активных пользователей.
   * Для уменьшения задержек предусмотрены:

     * Индексация полей `user_id`, `topic_id`, `level_id` и `session_id` на стороне БД.
     * Кеширование неизменяемых данных (список этапов, содержание уроков) на уровне CDN или в памяти приложения.
     * Пул соединений с базой данных (connection pool) для снижения накладных расходов на установку соединений.

2. **Безопасность хранения и передачи данных:**

   * **Аутентификация и авторизация:** все запросы к API требуют проверки токенов или сессионных идентификаторов; права преподавателя и ученика разграничены на уровне контроллеров.
   * **Хранение паролей:** используется PBKDF2/Bcrypt с солями для хэширования паролей в таблице `Tutors`.
   * **Защита от уязвимостей:** внедрены механизмы валидации входных данных (на стороне сервера и клиента), защита от CSRF/XSS через стандартные расширения Flask и настройку заголовков безопасности (Content Security Policy).
   * **Ротация резервных копий:** автоматизированные процедуры резервного копирования базы данных (ежечасно) и файлов сервиса (ежесуточно) с удалением старых копий, чтобы снизить риск утечки и обеспечить готовность к восстановлению.

Данные требования позволят обеспечить надёжность, устойчивость к нагрузкам и защиту пользовательских данных в рамках заявленных сценариев эксплуатации.

### 3.5. Разработка архитектурных диаграмм

Для наглядного представления структуры и поведения системы были выбраны четыре типа диаграмм: диаграммы последовательности, пользовательские сценарии, связи между компонентами системы и ER-диаграмма базы данных. Каждая из них призвана подчеркнуть определённый аспект архитектуры и обеспечить максимально полное понимание строения и функционирования программного средства.

#### 3.5.1. Диаграммы последовательности

Диаграммы последовательности иллюстрируют динамику взаимодействия между объектами и модулями в рамках ключевых процессов:

1. **Старт и идентификация пользователя**
   На первой диаграмме последовательно воспроизводится сценарий запроса `/api/session/start`:

   * Клиент инициирует HTTP-запрос, передавая cookie или URL-параметр.
   * Контроллер проверяет наличие записи в таблице `Users`.
   * В случае отсутствия создаются новые записи в `Users` и `Sessions`.
   * Контроллер возвращает ответ с URL первой страницы и параметрами сессии.

2. **Прохождение этапа**
   Вторая последовательность отражает логику POST-запроса `/api/user_levels`:

   * Клиент отправляет `{ user_id, level_id, session_id }`.
   * Сервис проверяет дубликат в `User_Level`.
   * При отсутствии дублирования вставляется запись, триггер обновляет `Progress`.
   * Сервис формирует ответ с актуальным процентом завершения и общим временем.

3. **Работа преподавателя**
   Третья диаграмма показывает сценарий создания ученика и отправки подсказки:

   * Преподаватель через UI инициирует POST `/api/tutors/{tutor_id}/students`.
   * Сервис создаёт `User` с полем `tutor_id`.
   * Далее пользователь-ученик получает ссылку и при первом входе автоматически ассоциируется.
   * Преподаватель отправляет подсказку через POST `/api/hints`, сервис сохраняет запись в `Hints` и уведомляет клиента.

При описании этих диаграмм особое внимание уделено последовательности вызовов и тому, как контроллер, сервисный слой и база данных обмениваются сообщениями. Выбор именно четырёх ключевых сценариев обусловлен их центральной ролью в пользовательском опыте и администрировании системы.

#### 3.5.2. Пользовательские сценарии

Пользовательские сценарии детализируют шаги, которые выполняют различные роли:

1. **Сценарий гостевого пользователя**

   * Вход на главную страницу → автоматическая регистрация → отображение первой инструкции.
   * Нажатие “Далее” → выбор раздела → начало прохождения этапов.

2. **Сценарий возвращающегося ученика**

   * Вход через сохранённые cookie → определение последнего пройденного уровня → перенаправление на соответствующую страницу.
   * Отображение прогресса и продолжение обучения с текущего шага.

3. **Сценарий преподавателя**

   * Регистрация учётной записи → подтверждение email → вход в панель управления.
   * Создание нового ученика: ввод имени и получение ссылочного токена.
   * Мониторинг прогресса учеников: выбор пользователя → просмотр процента завершения, количества этапов и времени.
   * Отправка подсказки: ввод текста → моментальное появление в интерфейсе ученика.

Каждый сценарий описан как линейная цепочка действий и реакций системы, с указанием точек принятия решений (например, “если пользователь уже зарегистрирован”) и возможных ветвлений (например, “при ошибке ввода пароля”). В тексте обозначены все варианты исходов: успешный, неуспешный и повторный.

#### 3.5.3. Диаграммы связей между компонентами системы

Чтобы наглядно представить статическую структуру приложения, составлена диаграмма компонентов, отображающая четыре основных пакета:

1. **Frontend-приложение**

   * Компоненты аутентификации, навигации и визуализации прогресса.
   * Модуль TutorDashboard для управления учениками и подсказками.
   * Клиентские сервисы для работы с REST-API и локальным хранилищем cookie.

2. **Backend-сервис (Flask)**

   * Контроллеры, принимающие HTTP-запросы и управляющие аутентификацией, маршрутизацией и валидацией.
   * Сервисный слой, отвечающий за бизнес-логику: регистрацию пользователей, обработку этапов, расчёт прогресса, управление подсказками.
   * DAO-слой, взаимодействующий с PostgreSQL через SQLAlchemy, с возможностью выполнения “сырых” SQL-запросов.

3. **СУБД (PostgreSQL)**

   * Таблицы `Users`, `Tutors`, `Topics`, `Levels`, `User_Level`, `Progress`, `Sessions`, `Hints`.
   * Триггерная логика для обновления агрегатов.

4. **Вспомогательный контейнер**

   * Задачи резервного копирования (`pg_dump`) и передачи бэкапов на удалённое хранилище.
   * Мониторинг (Prometheus-экспортер) и лог-агент (ELK-stack или подобный).

Стрелками показаны основные интерфейсы взаимодействия: REST-вызовы между Frontend и Backend, TCP-соединение к БД, запуск фоновых задач в контейнере бэкапов. Диаграмма подчёркивает независимость модулей и их чётко определённые границы ответственности.

#### 3.5.4. ER-диаграмма базы данных

ER-диаграмма описывает сущности и их связи:

* **Users** 1—\* **User\_Level** \*—1 **Levels**
* **Users** 1—\* **Sessions**
* **Users** \*—1 **Tutors** (через поле `tutor_id`)
* **Users** 1—\* **Hints** \*—1 **Tutors**
* **Topics** 1—\* **Levels**
* **Users** *—* **Topics** (через таблицу `Progress`)

Для каждой связи указаны кардинальности и направление внешних ключей. Диаграмма содержит основные атрибуты сущностей: первичные ключи, поля времени (`registered_at`, `completion_time`, `read_at`) и служебные идентификаторы. На схеме обозначены обязательные и опциональные атрибуты, а также индексы, влияющие на производительность выборок.

---

Таким образом, предложенные четыре диаграммы формируют целостное представление архитектуры системы: от описания последовательности взаимодействий и пользовательских сценариев до статических связей между компонентами и моделью данных.


