## **3. Разработка архитектуры программного средства**

### 3.1. Проектирование структуры системы

#### 3.1.1. Уровни и модули

1. **Клиентская часть (Frontend)**

   * SPA на основе современных веб-технологий (React/Vue/Angular)
   * Страницы тренажёра с пошаговым контентом (уроки)
   * Интерфейс для преподавателя: панель управления списком учеников, просмотр прогресса, отправка подсказок
   * Модули:

     * *AuthClient* — управление cookies/URL-идентификацией
     * *Navigator* — отображение и управление навигацией между этапами
     * *ProgressDisplay* — визуализация прогресса на каждой странице
     * *TutorDashboard* — интерфейс преподавателя

2. **Серверная часть (Backend)**

   * Фреймворк: Flask
   * Четырёхслойная архитектура:

     1. **REST API** — маршруты для клиентского приложения
     2. **Контроллеры (Views)** — приём запросов, базовая валидация, авторизация
     3. **Сервисный слой (Business Logic)** — реализация сценариев:

        * Сценарий «Старт / Продолжение»: регистрация, идентификация, выбор раздела
        * Сценарий «Прохождение этапа»: фиксация в `User_Level`, обновление `Progress`
        * Сценарий «Работа преподавателя»: CRUD для учеников, отправка/чтение подсказок
     4. **DAO (Data Access Objects)** — операции с PostgreSQL через ORM (SQLAlchemy)

3. **База данных (PostgreSQL)**

   * Схема полностью соответствует инфологической модели:

     * Таблицы: `Users`, `Tutors`, `Topics`, `Levels`, `User_Level`, `Progress`, `Sessions`, `Hints`
     * Индексы на полях `user_id`, `tutor_id`, `topic_id`, `session_id`
     * Триггеры / фоновые задачи:

       * При вставке в `User_Level` — пересчёт и обновление `Progress`
       * Ротация резервных копий (`pg_dump`) по расписанию

4. **Интеграции и прочее**

   * SMTP-сервис для подтверждения email преподавателей
   * Сторонний CDN для статики
   * (Опционально) Сервис локализации для перевода интерфейса

---

### 3.2. Описание взаимодействия компонентов

#### 3.2.1. Сценарий «Старт / Продолжение»

1. **Клиент** отправляет GET `/api/session/start`
2. **API / Контроллер** проверяет cookies или URL-параметр с `user_id`
3. Если **идентификатор отсутствует**:

   * Создается запись в `Users` (новый пользователь без `tutor_id`)
   * Новый `session_id` сохраняется в `Sessions`
   * Возвращается JSON с `user_id` и инструкция открыть `/lesson/1`
4. Если **идентификатор найден**:

   * Из `Progress` извлекается `topic_id` и `completion_percentage`
   * Определяется последний пройденный `level_id` в `User_Level`
   * Возвращается JSON с `resume_url` и прогрессом

#### 3.2.2. Сценарий «Прохождение этапа»

1. При переходе на страницу урока Frontend вызывает GET `/api/levels/{level_id}`
2. API возвращает набор данных:

   * Описание (текст)
   * Инструкции по скринридеру
   * Ссылки «Далее» (next\_level\_id)
3. После успешного выполнения задания Frontend шлет POST `/api/user_levels` с `{ user_id, level_id, session_id }`
4. Backend (Service):

   * Проверяет, не было ли уже прохождения этого уровня
   * Вставляет запись в `User_Level`
   * Триггером пересчитывается `Progress` (таблица `Progress`)
   * Возвращает обновлённый прогресс (`completion_percentage`, общее время)
5. Клиент обновляет индикатор прогресса и переходит на следующий урок

#### 3.2.3. Сценарий «Работа преподавателя»

1. **Регистрация преподавателя**

   * POST `/api/tutors/register` → валидация, создание `Tutors`, отправка письма с подтверждением
2. **Управление учениками**

   * **Создать ученика**: POST `/api/tutors/{tutor_id}/students` → создаёт `Users` с `tutor_id`
   * **Получить список**: GET `/api/tutors/{tutor_id}/students` → возвращает массив `{ user_id, name, progress }`
   * **Удалить связь**: DELETE `/api/tutors/{tutor_id}/students/{user_id}` → обнуляет у ученика `tutor_id`
3. **Отправка подсказок**

   * Преподаватель шлёт POST `/api/hints` с `{ tutor_id, user_id, message }`
   * В таблице `Hints` создаётся новая запись с `created_at`
4. **Чтение подсказок учеником**

   * При загрузке страницы урока клиент запрашивает GET `/api/hints/{user_id}`
   * API отдаёт список подсказок; при первом получении каждая подсказка получает `read_at` в БД

#### 3.2.4. Логирование и мониторинг

* Каждый запрос и ответ фиксируется в логах Flask (уровень INFO/ERROR).
* Метрики: количество активных сессий, среднее время урока, процент ошибок HTTP.
* Алерты при превышении допустимой задержки загрузки (> 5 сек.) или падении базы данных.
